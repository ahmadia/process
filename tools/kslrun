#!/usr/bin/env python

import os, re, sys, select, subprocess, logging, time, string, optparse
import cfgparse, tempfile, shutil, inspect

bgp_template = string.Template('''#!/usr/bin/env bash
#
# @ job_name            = ${job_name}
# @ job_type            = ${job_type}
# @ output              = ${job_out_name}
# @ error               = ${job_err_name}
# @ environment         = COPY_ALL;
# @ wall_clock_limit    = ${wall_time},${wall_time}
# @ notification        = ${notification}
# @ bg_size             = ${partition_size}
# @ cluster_list        = ${cluster_list}
# @ class               = ${ll_class}
# @ account_no          = ${account}

# @ queue

/bgsys/drivers/ppcfloor/bin/mpirun -exp_env LD_LIBRARY_PATH -env BG_MAPPING=${bg_map} -np ${np} -mode ${mode} ${command}
${done_command}
''')

x86_template = string.Template('''#!/usr/bin/env bash
#
# @ job_name            = ${job_name}
# @ job_type            = ${job_type}
# @ output              = ${job_out_name}
# @ error               = ${job_err_name}
# @ environment         = COPY_ALL;
# @ wall_clock_limit    = ${wall_time},${wall_time}
# @ notification        = ${notification}
# @ node                = ${partition_size}
# @ tasks_per_node      = ${tasks_per_node}
# @ cluster_list        = ${cluster_list}
# @ class               = ${ll_class}
# @ account_no          = ${account}

# @ queue

mpdboot â€“f $$LOADL_HOSTFILE
mpirun -np ${np} ${command}
mpdallexit

${done_command}
''')



def main():
    # mode depends on if we are running on neser or shaheen
    host_arch = os.uname()[4]
    
    o = optparse.OptionParser(usage="usage: %kslrun [options] exe_with_args\nSee /opt/share/ksl/system/config/kslrun.py for default arguments")
    c = cfgparse.ConfigParser(allow_py=True)

#    c.add_optparse_help_option(o)


    ### Run Options
    og = optparse.OptionGroup(o, "GENERAL")
    og.add_option("-v", "--verbose", action="store_true", 
                 help="print informational status messages to stdout")
    c.add_option('verbose')
    
    og.add_option("-d", "--debug", action="store_true",
                 help="enable debug mode (developer use)")
    c.add_option('debug')

    og.add_option("-r", "--no_std_redirect", action="store_true",
                 help="disable stdout/stderr redirection")
    c.add_option('no_std_redirect')
    
    og.add_option("-k", "--keep_ll_file", action="store_true",
                 help="do not delete LoadLeveler file after run")
    c.add_option('keep_ll_file')

    og.add_option('--no_notify', action="store_true",
                 help="do not send a notification email when job completes")

    o.add_option_group(og)

    ### LoadLeveler Options
    og = optparse.OptionGroup(o, "LOADLEVELER")
    og.add_option("--prefix", type='string',
                 help='prefix for output files (only meaningful if no_std_redirect is enabled')
    c.add_option('prefix')
    
    og.add_option("-j", "--job_name", type='string',
                 help="job_name as passed to LoadLeveler")
    c.add_option('job_name')

    og.add_option('-t', "--wall_time", type='string',
                 help="job wall_time as passed to LoadLeveler")
    c.add_option('wall_time')

    og.add_option('-c', "--ll_class", type='string',
                 help="job class as passed to LoadLeveler")
    c.add_option('ll_class')
      
    og.add_option("-a", "--account", type='string',
                 help="account number to charge")
    c.add_option('account')

    ### BGP-specific
    if host_arch == 'ppc64':
        og.add_option("-p", "--partition_size", type='int', 
                      help="size of the BGP partition to request")
        c.add_option('partition_size')

    o.add_option_group(og)

    ### MPI Options
    og = optparse.OptionGroup(o, "MPI")
    og.add_option("-n", "--np", type='int',
                 help="number of MPI processes to request")
    c.add_option('np')

    ### BGP-specific
    if host_arch == 'ppc64':
        og.add_option("-m", "--mode", type='string',
                      help="MPI mode to use (e.g. VN, DUAL, SMP)")
        c.add_option('mode')

        og.add_option("--map", type='string', dest='bg_map',
                      help="mapping of logical MPI processes to physical nodes/cores (e.g. XYZT, TXYZ, ...)")
        c.add_option('bg_map')

    o.add_option_group(og)

    # check /opt/share/ksl/system/config/$arch/kslrun.py, ~/.kslrun.py, and ./.kslrun.py
    sysfile = '/opt/share/ksl/system/config/%s/kslrun.py' % host_arch
    if os.path.isfile(sysfile):
        c.add_file(sysfile)
    homefile = os.path.expanduser('~/.kslrun.py')
    if os.path.isfile(homefile):
        c.add_file(homefile)
    herefile = '.kslrun.py'
    if os.path.isfile(herefile):
        c.add_file(herefile)
    
    (options, args) = c.parse(o)

    if options.debug:
        logging.basicConfig(level=logging.DEBUG,
                            format='%(asctime)s %(levelname)s %(message)s')
    elif options.verbose:
        logging.basicConfig(level=logging.INFO,
                            format='%(asctime)s %(levelname)s %(message)s')
    else:
        logging.basicConfig(level=logging.WARNING,
                            format='%(asctime)s %(levelname)s %(message)s')

    logger = logging.getLogger('ksl_srun')

    logger.debug("options")
    logger.debug(options)
    logger.debug("args")
    logger.debug(args)

    if not args:
        raise Exception("No executable was specified to kslrun!")

    tempdir = tempfile.mkdtemp()

    try:
        if not options.no_std_redirect:
            logger.info("setting up job_out/job_err named pipes in temporary directory")
            job_out_name = os.path.join(tempdir, "job_out")
            job_err_name = os.path.join(tempdir, "job_err")
            
            os.mkfifo(job_out_name)
            os.mkfifo(job_err_name)
            
            job_out_pipe = os.open(job_out_name, (os.O_RDONLY|os.O_NONBLOCK))
            job_err_pipe = os.open(job_err_name, (os.O_RDONLY|os.O_NONBLOCK))
            time.sleep(1) 
            job_done_name = os.path.join(tempdir, "job_done")
            done_command = 'touch ' + job_done_name
        else:
            job_out_name = options.prefix+'.out'
            job_err_name = options.prefix+'.err'
            done_command = ''
            
        logger.info("setting up LoadLeveler submission script")    

        ll_dict = dict(inspect.getmembers(options))
        ll_dict['command'] = string.join(args)
        ll_dict['job_out_name'] = job_out_name
        ll_dict['job_err_name'] = job_err_name
        ll_dict['done_command'] = done_command

        if options.no_notify:
            ll_dict['notification'] = 'never'
        else:
            ll_dict['notification'] = 'always'

        llfilename = setup_ll_file(options, ll_dict, tempdir)
        logger.info("submitting to LoadLeveler")
        (llout, llerr) = call_command("llsubmit " + llfilename)
        logger.info(llout)
    #    if len(llerr):
            # silent ignore currently
    #        logger.error(llerr)

        longllqid = llout.split(' ')[1]
        assert 'fen1-a.shaheen.kaust.edu.sa' in longllqid, "Unable to determine llq job id from output, %s" % llout
        llqid = longllqid.replace("shaheen.kaust.edu.sa.","") + ".0"

        if not options.no_std_redirect:
            logger.info("following job_out/job_err named pipes and watching for job_done file")
            job_poll = select.poll()
            job_poll.register(job_out_pipe)
            job_poll.register(job_err_pipe)
            
            watch_pipes(job_poll, job_out_pipe, job_err_pipe,
                        job_done_name, llqid)
        else:
            logger.info("job submitted")
    except:
        cleanup(options, logger, tempdir)
        raise
    cleanup(options, logger, tempdir)

def cleanup(options, logger, tempdir):
    if options.debug:
        logger.debug("not deleting temporary working directory: " + tempdir)
    else:
        logger.info("deleting temporary files")
        shutil.rmtree(tempdir)
    if options.debug or options.keep_ll_file:
        logger.debug("not deleting ksl_submit.ll")
    else:
        try:
            os.remove('ksl_submit.ll')
        except:
            pass
            
def watch_pipes(job_poll, job_out_pipe, job_err_pipe, job_done_name, llqid):
    logger = logging.getLogger('ksl_srun')
    while True:  # see return condition in hangup check        
        # handle any output
        handle_output(job_poll, job_out_pipe, job_err_pipe)

        # now check for hangup
        if check_hangup(job_done_name):
            logger.info("Received a Hang-Up")
            # handle any output before returning, but give file system
            # a chance to clear named pipes  
            time.sleep(5)
            handle_output(job_poll, job_out_pipe, job_err_pipe)
            return

def handle_output(job_poll, job_out_pipe, job_err_pipe):
    time.sleep(1)
    active_pipes = job_poll.poll(1000)
    for fileid, mask in active_pipes:
        if job_out_pipe is fileid:
            while True:
                try:
                    buf = os.read(job_out_pipe,1024)
                    if len(buf)==0:
                        break
                    sys.stdout.write(buf)
                except:
                    time.sleep(1)
        if job_err_pipe is fileid:
            while True:
                try:
                    buf = os.read(job_err_pipe,1024)
                    if len(buf)==0:
                        break
                    sys.stderr.write(buf)
                except:
                    time.sleep(1)

        

def setup_ll_file(options, host_arch, ll_dict, tempdir):
    logger = logging.getLogger('ksl_srun')
    logger.debug(ll_dict)
    if options.keep_ll_file or options.debug:
        ll_filename = "./ksl_submit.ll"
    else:
        ll_filename = os.path.join(tempdir, "ksl_submit.ll")
    ll_file = open(ll_filename, 'w')

    if host_arch == 'ppc64':
        ll_file_contents = bgp_template.substitute(ll_dict)
    else:
        tpn = float(ll_dict['np']/ll_dict['partition_size'])
        assert tpn in range(1,9), 'Invalid # tasks per node, %d!' % tpn
        ll_dict['tasks_per_node'] = tpn
        ll_file_contents = x86_template.substitute(ll_dict)

    ll_file.write(ll_file_contents)        ll_file_contents = bgp_template.substitute(ll_dict)

    logger.debug(ll_file_contents)
    logger.debug("written to ksl_submit.ll")
    ll_file.close()

    return ll_filename

def check_hangup(job_done_name):
    logger = logging.getLogger('ksl_srun')
    logger.debug("checking for hangup file " + job_done_name)
    return os.path.exists(job_done_name)

def call_command(command):
    process = subprocess.Popen(command.split(' '),
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    return process.communicate()

if __name__ == "__main__":
    try:
        main()
    except SystemExit, e:
        raise
    except:
        print """
================================================================================
||           *There was some sort of error running the script*                ||
||       Please report to Aron Ahmadia <aron.ahmadia@kaust.edu.sa>            ||
================================================================================

Error stack follows
"""
        raise 
